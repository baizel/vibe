{"ast":null,"code":"import ExpoSecureStore from './ExpoSecureStore';\nimport { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';\nexport const AFTER_FIRST_UNLOCK = ExpoSecureStore.AFTER_FIRST_UNLOCK;\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY = ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\nexport const ALWAYS = ExpoSecureStore.ALWAYS;\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY = ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\nexport const ALWAYS_THIS_DEVICE_ONLY = ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\nexport const WHEN_UNLOCKED = ExpoSecureStore.WHEN_UNLOCKED;\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY = ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\nexport async function isAvailableAsync() {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\nexport async function deleteItemAsync(key, options = {}) {\n  ensureValidKey(key);\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\nexport async function getItemAsync(key, options = {}) {\n  ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\nexport async function setItemAsync(key, value, options = {}) {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(`Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`);\n  }\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\nexport function setItem(key, value, options = {}) {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(`Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`);\n  }\n  return ExpoSecureStore.setValueWithKeySync(value, key, options);\n}\nexport function getItem(key, options = {}) {\n  ensureValidKey(key);\n  return ExpoSecureStore.getValueWithKeySync(key, options);\n}\nexport function canUseBiometricAuthentication() {\n  return ExpoSecureStore.canUseBiometricAuthentication();\n}\nfunction ensureValidKey(key) {\n  if (!isValidKey(key)) {\n    throw new Error(`Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`);\n  }\n}\nfunction isValidKey(key) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\nfunction isValidValue(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (byteCountOverLimit(value, VALUE_BYTES_LIMIT)) {\n    console.warn(`Value being stored in SecureStore is larger than ${VALUE_BYTES_LIMIT} bytes and it may not be stored successfully. In a future SDK version, this call may throw an error.`);\n  }\n  return true;\n}","map":{"version":3,"names":["ExpoSecureStore","byteCountOverLimit","VALUE_BYTES_LIMIT","AFTER_FIRST_UNLOCK","AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY","ALWAYS","WHEN_PASSCODE_SET_THIS_DEVICE_ONLY","ALWAYS_THIS_DEVICE_ONLY","WHEN_UNLOCKED","WHEN_UNLOCKED_THIS_DEVICE_ONLY","isAvailableAsync","getValueWithKeyAsync","deleteItemAsync","key","options","ensureValidKey","deleteValueWithKeyAsync","getItemAsync","setItemAsync","value","isValidValue","Error","setValueWithKeyAsync","setItem","setValueWithKeySync","getItem","getValueWithKeySync","canUseBiometricAuthentication","isValidKey","test","console","warn"],"sources":["/Users/baizel/project/fresh-trio/mobile/node_modules/expo-secure-store/src/SecureStore.ts"],"sourcesContent":["import ExpoSecureStore from './ExpoSecureStore';\nimport { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';\n\nexport type KeychainAccessibilityConstant = number;\n\n// @needsAudit\n/**\n * The data in the keychain item cannot be accessed after a restart until the device has been\n * unlocked once by the user. This may be useful if you need to access the item when the phone\n * is locked.\n */\nexport const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore.AFTER_FIRST_UNLOCK;\n\n// @needsAudit\n/**\n * Similar to `AFTER_FIRST_UNLOCK`, except the entry is not migrated to a new device when restoring\n * from a backup.\n */\nexport const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can always be accessed regardless of whether the device is locked.\n * This is the least secure option.\n *\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK`.\n */\nexport const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED_THIS_DEVICE_ONLY`, except the user must have set a passcode in order to\n * store an entry. If the user removes their passcode, the entry will be deleted.\n */\nexport const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * Similar to `ALWAYS`, except the entry is not migrated to a new device when restoring from a backup.\n *\n * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY`.\n */\nexport const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;\n\n// @needsAudit\n/**\n * The data in the keychain item can be accessed only while the device is unlocked by the user.\n */\nexport const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN_UNLOCKED;\n\n// @needsAudit\n/**\n * Similar to `WHEN_UNLOCKED`, except the entry is not migrated to a new device when restoring from\n * a backup.\n */\nexport const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =\n  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;\n\n// @needsAudit\nexport type SecureStoreOptions = {\n  /**\n   * - Android: Equivalent of the public/private key pair `Alias`.\n   * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).\n   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.\n   */\n  keychainService?: string;\n  /**\n   * Option responsible for enabling the usage of the user authentication methods available on the device while\n   * accessing data stored in SecureStore.\n   * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))\n   *   (requires API 23).\n   * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).\n   * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`\n   * value used for the others non-authenticated operations.\n   *\n   * This option works slightly differently across platforms: On Android, user authentication is required for all operations.\n   * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).\n   *\n   * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.\n   * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.\n   *\n   */\n  requireAuthentication?: boolean;\n  /**\n   * Custom message displayed to the user while `requireAuthentication` option is turned on.\n   */\n  authenticationPrompt?: string;\n  /**\n   * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.\n   * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).\n   * @default SecureStore.WHEN_UNLOCKED\n   * @platform ios\n   */\n  keychainAccessible?: KeychainAccessibilityConstant;\n\n  /**\n   * Specifies the access group the stored entry belongs to.\n   * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).\n   * @platform ios\n   */\n  accessGroup?: string;\n};\n\n// @needsAudit\n/**\n * Returns whether the SecureStore API is enabled on the current device. This does not check the app\n * permissions.\n *\n * @return Promise which fulfils with a `boolean`, indicating whether the SecureStore API is available\n * on the current device. Currently, this resolves `true` on Android and iOS only.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!ExpoSecureStore.getValueWithKeyAsync;\n}\n\n// @needsAudit\n/**\n * Delete the value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that rejects if the value can't be deleted.\n */\nexport async function deleteItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  ensureValidKey(key);\n\n  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Reads the stored value associated with the provided key.\n *\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that resolves to the previously stored value. It resolves with `null` if there is no entry\n * for the given key or if the key has been invalidated. It rejects if an error occurs while retrieving the value.\n *\n * > Keys are invalidated by the system when biometrics change, such as adding a new fingerprint or changing the face profile used for face recognition.\n * > After a key has been invalidated, it becomes impossible to read its value.\n * > This only applies to values stored with `requireAuthentication` set to `true`.\n */\nexport async function getItemAsync(\n  key: string,\n  options: SecureStoreOptions = {}\n): Promise<string | null> {\n  ensureValidKey(key);\n  return await ExpoSecureStore.getValueWithKeyAsync(key, options);\n}\n\n// @needsAudit\n/**\n * Stores a key–value pair.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return A promise that rejects if value cannot be stored on the device.\n */\nexport async function setItemAsync(\n  key: string,\n  value: string,\n  options: SecureStoreOptions = {}\n): Promise<void> {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n\n  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);\n}\n\n/**\n * Stores a key–value pair synchronously.\n * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.\n *\n * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.\n * @param value The value to store. Size limit is 2048 bytes.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n */\nexport function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {\n  ensureValidKey(key);\n  if (!isValidValue(value)) {\n    throw new Error(\n      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`\n    );\n  }\n\n  return ExpoSecureStore.setValueWithKeySync(value, key, options);\n}\n\n/**\n * Synchronously reads the stored value associated with the provided key.\n * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`\n * > option set to `true` until the user authenticates.\n * @param key The key that was used to store the associated value.\n * @param options An [`SecureStoreOptions`](#securestoreoptions) object.\n *\n * @return Previously stored value. It resolves with `null` if there is no entry\n * for the given key or if the key has been invalidated.\n */\nexport function getItem(key: string, options: SecureStoreOptions = {}): string | null {\n  ensureValidKey(key);\n  return ExpoSecureStore.getValueWithKeySync(key, options);\n}\n\n/**\n * Checks if the value can be saved with `requireAuthentication` option enabled.\n * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.\n * @platform android\n * @platform ios\n */\nexport function canUseBiometricAuthentication(): boolean {\n  return ExpoSecureStore.canUseBiometricAuthentication();\n}\n\nfunction ensureValidKey(key: string) {\n  if (!isValidKey(key)) {\n    throw new Error(\n      `Invalid key provided to SecureStore. Keys must not be empty and contain only alphanumeric characters, \".\", \"-\", and \"_\".`\n    );\n  }\n}\n\nfunction isValidKey(key: string) {\n  return typeof key === 'string' && /^[\\w.-]+$/.test(key);\n}\n\nfunction isValidValue(value: string) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  if (byteCountOverLimit(value, VALUE_BYTES_LIMIT)) {\n    console.warn(\n      `Value being stored in SecureStore is larger than ${VALUE_BYTES_LIMIT} bytes and it may not be stored successfully. In a future SDK version, this call may throw an error.`\n    );\n  }\n  return true;\n}\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,mBAAmB;AAC/C,SAASC,kBAAkB,EAAEC,iBAAiB,QAAQ,eAAe;AAUrE,OAAO,MAAMC,kBAAkB,GAAkCH,eAAe,CAACG,kBAAkB;AAOnG,OAAO,MAAMC,mCAAmC,GAC9CJ,eAAe,CAACI,mCAAmC;AASrD,OAAO,MAAMC,MAAM,GAAkCL,eAAe,CAACK,MAAM;AAO3E,OAAO,MAAMC,kCAAkC,GAC7CN,eAAe,CAACM,kCAAkC;AAQpD,OAAO,MAAMC,uBAAuB,GAClCP,eAAe,CAACO,uBAAuB;AAMzC,OAAO,MAAMC,aAAa,GAAkCR,eAAe,CAACQ,aAAa;AAOzF,OAAO,MAAMC,8BAA8B,GACzCT,eAAe,CAACS,8BAA8B;AAuDhD,OAAO,eAAeC,gBAAgBA,CAAA;EACpC,OAAO,CAAC,CAACV,eAAe,CAACW,oBAAoB;AAC/C;AAWA,OAAO,eAAeC,eAAeA,CACnCC,GAAW,EACXC,OAAA,GAA8B,EAAE;EAEhCC,cAAc,CAACF,GAAG,CAAC;EAEnB,MAAMb,eAAe,CAACgB,uBAAuB,CAACH,GAAG,EAAEC,OAAO,CAAC;AAC7D;AAgBA,OAAO,eAAeG,YAAYA,CAChCJ,GAAW,EACXC,OAAA,GAA8B,EAAE;EAEhCC,cAAc,CAACF,GAAG,CAAC;EACnB,OAAO,MAAMb,eAAe,CAACW,oBAAoB,CAACE,GAAG,EAAEC,OAAO,CAAC;AACjE;AAYA,OAAO,eAAeI,YAAYA,CAChCL,GAAW,EACXM,KAAa,EACbL,OAAA,GAA8B,EAAE;EAEhCC,cAAc,CAACF,GAAG,CAAC;EACnB,IAAI,CAACO,YAAY,CAACD,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIE,KAAK,CACb,6HAA6H,CAC9H;EACH;EAEA,MAAMrB,eAAe,CAACsB,oBAAoB,CAACH,KAAK,EAAEN,GAAG,EAAEC,OAAO,CAAC;AACjE;AAWA,OAAM,SAAUS,OAAOA,CAACV,GAAW,EAAEM,KAAa,EAAEL,OAAA,GAA8B,EAAE;EAClFC,cAAc,CAACF,GAAG,CAAC;EACnB,IAAI,CAACO,YAAY,CAACD,KAAK,CAAC,EAAE;IACxB,MAAM,IAAIE,KAAK,CACb,6HAA6H,CAC9H;EACH;EAEA,OAAOrB,eAAe,CAACwB,mBAAmB,CAACL,KAAK,EAAEN,GAAG,EAAEC,OAAO,CAAC;AACjE;AAYA,OAAM,SAAUW,OAAOA,CAACZ,GAAW,EAAEC,OAAA,GAA8B,EAAE;EACnEC,cAAc,CAACF,GAAG,CAAC;EACnB,OAAOb,eAAe,CAAC0B,mBAAmB,CAACb,GAAG,EAAEC,OAAO,CAAC;AAC1D;AAQA,OAAM,SAAUa,6BAA6BA,CAAA;EAC3C,OAAO3B,eAAe,CAAC2B,6BAA6B,EAAE;AACxD;AAEA,SAASZ,cAAcA,CAACF,GAAW;EACjC,IAAI,CAACe,UAAU,CAACf,GAAG,CAAC,EAAE;IACpB,MAAM,IAAIQ,KAAK,CACb,0HAA0H,CAC3H;EACH;AACF;AAEA,SAASO,UAAUA,CAACf,GAAW;EAC7B,OAAO,OAAOA,GAAG,KAAK,QAAQ,IAAI,WAAW,CAACgB,IAAI,CAAChB,GAAG,CAAC;AACzD;AAEA,SAASO,YAAYA,CAACD,KAAa;EACjC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAO,KAAK;EACd;EACA,IAAIlB,kBAAkB,CAACkB,KAAK,EAAEjB,iBAAiB,CAAC,EAAE;IAChD4B,OAAO,CAACC,IAAI,CACV,oDAAoD7B,iBAAiB,sGAAsG,CAC5K;EACH;EACA,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}